\input{header}
\author{Дмитрий Понят\'{о}в\ \email{dponyatov@gmail.com}}
\title{HOWTO: как написать интерпретатор$^*$\\(программирование в свободном синтаксисе)}
\begin{document}\secdown
\maketitle
\tableofcontents

\secly{Введение$^*$}

Программа, выполняющая преобразование
\termdef{исходного текста}{исходный текст}\ программы:
\begin{description}
	\item[\termdef{транслятор}{транслятор}]\label{translator}\ ---
		в другой язык программирования
	\item[\termdef{компилятор}{компилятор}]\label{compiler}\ ---
		в машинный код, сохраняемый в \termdef{объектные файлы}{объектный файл}
	\item[\termdef{интерпретатор}{интерпретатор}]\label{interpreter}\ ---
		вариант \emph{компилятора}, выполняющий \emph{генерацию программы в
		ОЗУ}\ в виде машинного
		кода, или \termdef{байт-кода}{байт-код}\note{машинный код виртуальной
		машины, выполняемый программно, т.е. \emph{интерпретируемый}}.
		Практически все современные интерпретаторы используют технику
		\termdef{JIT-компиляции}{JIT-компиляция}\ --- генерация машинного кода
		в ОЗУ из исходного текста\note{точнее AST-дерева, полученного 
		\termdef{разбором}{разбор}\ исходника}\ или \termdef{промежуточного 
		представления}{промежуточное представление}\ программы в виде
		байт-кода.
		
		\emph{Интерпретатором например является
		Java\note{и Android без кода NDK}}:
		байт-код из .class и .jar файлов преобразуется в машинный код
		после запуска программы (в рантайме). Одновременно Java можно называть
		и компилятором, так как он компилирует программы в байт-код,
		эквивалентный машинному коду виртуальной Java-машины: стадии компиляции
		и выполнения разделены.
	\item[\termdef{скрипт-движок}{скрипт-движок}]\label{script}\ ---
		интерпретатор, встраиваемый в другие программы, и используемый
		для чтения файлов конфигурации и написания макросов. В комплект поставки
		обычно включается хост-среда, позволяющая запускать интерпретатор
		скрипт-языка в пакетном режиме\note{как обычную консольную программу},
		в составе веб-сервера, или интерактивной среды\note{IDE разработчика,
		или полноценной графической пользовательской среды, как языки
	SmallTalk-группы}
\end{description}

*\ в этом HOWTO описана реализация \xref{скриптового языка}{script}\ с
алголоподобным синтаксисом.

\secly{Структура компилятора}

\includegraphics[height=0.98\textheight]{struct.pdf}

\secly{FSP: программирование в свободном синтаксисе}

FSP\note{[F]ree [S]yntax [P]rogramming}\ --- метод \term{программирования
в свободном синсаксисе}: центральную роль в вашей программе занимает
\termdef{интерпретатор входного языка}{интерпретатор входного языка}.
\term{Свободный синтаксис}\ входного языка вы можете произвольно менять,
описывая на нем логику программы, файлы конфигурации, GUI и пользовательский
командный интерфейс (CLI).

\secly{Скелет лексической программы}

Создадим Скелет программы использующей лексический разбор $\rightarrow$
лексической программы $\rightarrow$ lexical skeleton $\rightarrow$ skelex:

\begin{verbatim}
mkdir script
cd script
touch src.src log.log ypp.ypp lpp.lpp hpp.hpp cpp.cpp Makefile bat.bat .gitignore
echo gvim -p src.src log.log ypp...cpp.cpp Makefile bat.bat .gitignore >> bat.bat
bat
\end{verbatim}

Отредактируйте файлы\note{если вы пользуетесь Vimом под Windows}:

\lstx{bat.bat : gvim win32 helper}{../bat.bat}

\bigskip
Если вы пользуетесь Git, создайте на GitHub репозиторий, и подключите его к
проекту\note{у вас уже должны быть настроены ключи SSH-доступа для вашего
аккаунта на GitHub}:
\begin{verbatim}
git init
git remote add gh git@github.com:yourname/script.git
git commit -a -m "+skelex"
git push -u gh master
\end{verbatim}
\lstx{.gitignore}{../.gitignore}

\begin{tabular}{l l}
	src.src & исходный код \\
	log.log & лог транслятора \\
	\hline
	ypp.ypp & лексер /flex/ \\
	lpp.lpp & парсер /bison/ \\
	hpp.hpp & хедеры \\
	cpp.cpp & C++ ядро интерпретатора \\
	Makefile & \\
	\hline
	bat.bat & gvim win32 helper \\
	.gitignore & \\
\end{tabular}

\lst{Makefile}{tmp/mk.mk}{make}

\bigskip
Содержимое остальных файлов, описанное далее, легко скопипастить с

\bigskip
\url{https://github.com/ponyatov/script.git}.

\bigskip
В качестве примера рассмотрим описание скелета FSP-программы на нашем
собственном языке:

\lstx{skeleton.src}{../src.src}

\secly{Синтаксис языка bI}

\begin{verbatim}
                                    # строчный комментарий
\end{verbatim}
\begin{verbatim}
                                    # скалярные типы:
Sym.bol_01                          # символ
'строка
\tможет быть\sмногострочной'        # \t табуляция \n конец строки \s пробел
\end{verbatim}
\begin{verbatim}
                                    # композитные типы:
[ flat list ]                       # плоский список
lisp,like,cons,list                 # список на базе cons-ячеек в стиле Lisp
\end{verbatim}
\begin{verbatim}
                                    # выражения в инфиксном синтаксисе
A+B-C*D/E^F                         # арифметические операторы
sin@X+cos@Y/exp@Z                   # применение встроенных функций
Z = sqrt@(X^2+Y^2)                  # биндинг выражений (назначение, уравнение)
\end{verbatim}
\begin{verbatim}
pp = {P: P+'.pp'}                   # лямбда-функции, создание именованной функции
x.x = {X: pp@X+'.'+pp@X}
files = x.x@y + x.x|y,l,h,c	        # одиночное и map- применение функции
\end{verbatim}
\begin{verbatim}
class:object                        # объектно-ориентированное программирование
class:lexeme                        # одиночное наследование без модификации
object,lexeme:comment               # множественное наследование
    % regexp = '#[^\n]*'            # поле данных
    % lex = {lexrule@regexp,'{}'}   # метод (вызов функции-генератора правила лексера)
comment@apply <comment:bracks>      # инстанциация объекта через @ и <:>
\end{verbatim}

\secrel{Синтаксический анализатор}\secdown

\secrel{Лексер /flex/}

\termdef{Лексер}{лексер}\ --- компонент, выполняющий разделение исходного 
текста программы на элементы: \termdef{токены}{токен}.

\bigskip
Лексер умеет работать только последовательно, и не способен разпознавать такие
элементы как вложенные скобки. Задача лексера\ --- объединить определенные
смежные символы в один объект-токен, и присвоить ему метку типа (число, строка, 
оператор,..). Также лексер может запоминать в токене его положение в 
исходнике: имя файла, номер строки и столбца.

Лексер можно написать полностью самому, реализовав интерфейс:
\lst{hpp.hpp интерфейс лексера}{tmp/lexer.hpp}{C++}

Макрос \verb|TOC(C,X)|\ описывает внутреннюю логику функции \verb|yylex()|:
набирать символы из входного потока в буфер, создать объект-токен, вернув 
указатель через \verb|yylval.o|(bject), и вернуть целочисленный код токена.

\bigskip
В большинстве случаев\note{когда набор правил лескера не меняется в процессе
работы программы}\ удобнее воспользоваться типовой программой-генератором
лексеров \prog{flex}.

Структура файла правил лексера \file{lpp.lpp}:
\begin{verbatim}
%{
заголовок (С++ код)
%}
%option noyywrap
%option yylineno
%x state1 state2..
%%
правила
%%
необязательный С++ код
\end{verbatim}

Если в файл лексера добавить опцию \verb|%option main|, полученный код лексера
можно скомпилировать как самостоятельную программу, и использовать ее как
инструмент интеллектуального поиска/замены текста, как пример
см. файл \verb|doc/src2lst.lex|

\lst{lpp.lpp заголовок лексера}{tmp/lexer.head}{C++}

Правила лексера задаются парами: \verb|<регулярное выражение> <C++ код>|

Если набор символов совпадает с правилом, заданным регулярным выражением,
срабатывает указанный сишный код:

\lst{lpp.lpp комментарий}{tmp/lexer.comment}{C++}

игнорировать любой текст от символа \#\ до конца строки

\bigskip
Самый сложный набор правил\ --- разбор строки, т.к. он требует отдельный
набор правил. Переключение набора правил лексера выполняется через
\emph{состояния}. Стартовое (и единственное) состояние лексера \verb|INITIAL|.
Дополнительные состояния добавляются через директиву \verb|%x|. Добавим 
дополнительное состояние \verb|lexstring|, и укажем специальный набор правил
для разбора строки:

\lst{lpp.lpp разбор строки}{tmp/lexer.string}{C++}

Макрос \verb|BEGIN()|\ переключает состояния, закрывающее правило
\verb|<lexstring>'|\ переключает лексер в начальное состояние, и возвращает
токен-строку.

\bigskip
Основным объектом нашего языка является \termdef{символ}{символ}:

\lst{lpp.lpp лексемы-символы}{tmp/lexer.sym}{C++}

Как символы определятся все \termdef{лексемы}{лексема}, состоящие из букв,
цифр, знаков подчеркивания и точки\note{нужна для распознавания имен файлов
как символов}.

\lst{lpp.lpp скобки}{tmp/lexer.brs}{C++}
\lst{lpp.lpp инфиксные операторы}{tmp/lexer.ops}{C++}

И наконец, будем игнорировать все пробельные символы:
\lst{lpp.lpp пробелы}{tmp/lexer.spaces}{C++}

\bigskip
Вызв генератора \prog{flex}\ приведет к появлению файла 
\verb|lex.yy.c|\ с кодом лексера:
\lst{Makefile: генерация кода лексера}{tmp/lexer.mk}{make}

\secrel{Парсер /bison/}

\termdef{Парсер}{парсер}

\lst{Makefile: генерация кода парсера}{tmp/parser.mk}{make}

\secup

\clearpage
\addcontentsline{toc}{chapter}{Индекс}
\printindex
\end{document}
