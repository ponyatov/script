\input{header}
\author{Дмитрий Понят\'{о}в\ \email{dponyatov@gmail.com}}
\title{HOWTO: как написать компилятор$^*$}
\begin{document}\secdown
\maketitle
\tableofcontents

\secly{Введение$^*$}

Программа, выполняющая преобразование
\termdef{исходного текста}{исходный текст}\ программы:
\begin{description}
	\item[\termdef{транслятор}{транслятор}]\label{translator}\ ---
		в другой язык программирования
	\item[\termdef{компилятор}{компилятор}]\label{compiler}\ ---
		в машинный код, сохраняемый в \termdef{объектные файлы}{объектный файл}
	\item[\termdef{интерпретатор}{интерпретатор}]\label{interpreter}\ ---
		вариант \emph{компилятора}, выполняющий \emph{генерацию программы в
		ОЗУ}\ в виде машинного
		кода, или \termdef{байт-кода}{байт-код}\note{машинный код виртуальной
		машины, выполняемый программно, т.е. \emph{интерпретируемый}}.
		Практически все современные интерпретаторы используют технику
		\termdef{JIT-компиляции}{JIT-компиляция}\ --- генерация машинного кода
		в ОЗУ из исходного текста\note{точнее AST-дерева, полученного 
		\termdef{разбором}{разбор}\ исходника}\ или \termdef{промежуточного 
		представления}{промежуточное представление}\ программы в виде
		байт-кода.
		
		\emph{Интерпретатором например является
		Java\note{и Android без кода NDK}}:
		байт-код из .class и .jar файлов преобразуется в машинный код
		после запуска программы (в рантайме).
	\item[\termdef{скрипт-движок}{скрипт-движок}]\label{script}\ ---
		интерпретатор, встраиваемый в другие программы, и используемый
		для чтения файлов конфигурации и написания макросов. В комплект поставки
		обычно включается хост-среда, позволяющая запускать интерпретатор
		скрипт-языка в пакетном режиме\note{как обычную консольную программу},
		в составе веб-сервера, или интерактивной среды\note{IDE разработчика,
		или полноценной графической пользовательской среды, как языки
	SmallTalk-группы}
\end{description}

*\ в этом HOWTO описана реализация \xref{скриптового языка}{script}\ с
алголоподобным синтаксисом.

\secly{FSP: программирование в свободном синтаксисе}

FSP\note{[F]ree [S]yntax [P]rogramming}\ --- метод \term{программирования
в свободном синсаксисе}: центральную роль в вашей программе занимает
\termdef{интерпретатор входного языка}{интерпретатор входного языка}.
\term{Свободный синтаксис}\ входного языка вы можете произвольно менять,
описывая на нем логику программы, файлы конфигурации, GUI и пользовательский
командный интерфейс (CLI).

\secly{Структура компилятора}

\includegraphics[height=0.95\textheight]{struct.pdf}

\secrel{Синтаксический анализатор}\secdown

\secrel{Лексер /flex/}

\termdef{Лексер}{лексер}\ --- компонент, выполняющий разделение исходного 
текста программы на элементы: \termdef{токены}{токен}.

\bigskip
Лексер умеет работать только последовательно, и не способен разпознавать такие
элементы как вложенные скобки. Задача лексера\ --- объединить определенные
смежные символы в один объект-токен, и присвоить ему метку типа (число, строка, 
оператор,..). Также лексер может запоминать в токене его положение в 
исходнике: имя файла, номер строки и столбца.

Лексер можно написать полностью самому, реализовав интерфейс:
\lst{hpp.hpp интерфейс лексера}{tmp/lexer.hpp}{C++}

Макрос \verb|TOC(C,X)|\ описывает внутреннюю логику функции \verb|yylex()|:
набирать символы из входного потока в буфер, создать объект-токен, вернув 
указатель через \verb|yylval.o|(bject), и вернуть целочисленный код токена.

\bigskip
В большинстве случаев\note{когда набор правил лескера не меняется в процессе
работы программы}\ удобнее воспользоваться типовой программой-генератором
лексеров \prog{flex}.

Структура файла правил лексера \file{lpp.lpp}:
\begin{verbatim}
%{
заголовок (С++ код)
%}
%option noyywrap
%option yylineno
%x state1 state2..
%%
правила
%%
необязательный С++ код
\end{verbatim}

Если в файл лексера добавить опцию \verb|%option main|, полученный код лексера
можно скомпилировать как самостоятельную программу, и использовать ее как
инструмент интеллектуального поиска/замены текста, как пример
см. файл \verb|doc/src2lst.lex|

\lst{lpp.lpp заголовок лексера}{tmp/lexer.head}{C++}

Правила лексера задаются парами: \verb|<регулярное выражение> <C++ код>|

Если набор символов совпадает с правилом, заданным регулярным выражением,
срабатывает указанный сишный код:

\lst{lpp.lpp комментарий}{tmp/lexer.comment}{C++}

игнорировать любой текст от символа \#\ до конца строки

Самый сложный набор правил\ --- разбор строки, т.к. он требует отдельный
набор правил. Переключение набора правил лексера выполняется через
\emph{состояния}. Стартовое (и единственное) состояние лексера \verb|INITIAL|.
Дополнительные состояния добавляются через директиву \verb|%x|. Добавим 
дополнительное состояние \verb|lexstring|, и укажем специальный набор правил
для разбора строки:

\lst{lpp.lpp разбор строки}{tmp/lexer.string}{C++}

Макрос \verb|BEGIN()|\ переключает состояния, закрывающее правило
\verb|<lexstring>'|\ переключает лексер в начальное состояние, и возвращает
токен-строку.

Основным объектом нашего языка является \termdef{символ}{символ}:

\lst{lpp.lpp лексемы-символы}{tmp/lexer.sym}{C++}

Как символы определятся все \termdef{лексемы}{лексема}, состоящие из букв,
цифр, знаков подчеркивания и точки\note{нужна для распознавания имен файлов
как символов}.

\secrel{Парсер /bison/}

\termdef{Парсер}{парсер}

\secup

\clearpage
\addcontentsline{toc}{chapter}{Индекс}
\printindex
\end{document}
