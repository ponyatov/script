\input{header}
\author{Дмитрий Понят\'{о}в\ \email{dponyatov@gmail.com}}
\title{HOWTO: как написать компилятор$^*$}
\begin{document}\secdown
\maketitle
\tableofcontents

\secly{Введение$^*$}

Программа, выполняющая преобразование
\termdef{исходного текста}{исходный текст}\ программы:
\begin{description}
	\item[\termdef{транслятор}{транслятор}]\label{translator}\ ---
		в другой язык программирования
	\item[\termdef{компилятор}{компилятор}]\label{compiler}\ ---
		в машинный код, сохраняемый в \termdef{объектные файлы}{объектный файл}
	\item[\termdef{интерпретатор}{интерпретатор}]\label{interpreter}\ ---
		вариант \emph{компилятора}, выполняющий \emph{генерацию программы в
		ОЗУ}\ в виде машинного
		кода, или \termdef{байт-кода}{байт-код}\note{машинный код виртуальной
		машины, выполняемый программно, т.е. \emph{интерпретируемый}}.
		Практически все современные интерпретаторы используют технику
		\termdef{JIT-компиляции}{JIT-компиляция}\ --- генерация машинного кода
		в ОЗУ из исходного текста\note{точнее AST-дерева, полученного 
		\termdef{разбором}{разбор}\ исходника}\ или \termdef{промежуточного 
		представления}{промежуточное представление}\ программы в виде
		байт-кода.
		
		\emph{Интерпретатором например является
		Java\note{и Android без кода NDK}}:
		байт-код из .class и .jar файлов преобразуется в машинный код
		после запуска программы (в рантайме).
	\item[\termdef{скрипт-движок}{скрипт-движок}]\label{script}\ ---
		интерпретатор, встраиваемый в другие программы, и используемый
		для чтения файлов конфигурации и написания макросов. В комплект поставки
		обычно включается хост-среда, позволяющая запускать интерпретатор
		скрипт-языка в пакетном режиме\note{как обычную консольную программу},
		в составе веб-сервера, или интерактивной среды\note{IDE разработчика,
		или полноценной графической пользовательской среды, как языки
	SmallTalk-группы}
\end{description}

*\ в этом HOWTO описана реализация \xref{скриптового языка}{script}\ с
алголоподобным синтаксисом.

\secly{Структура компилятора}

\includegraphics[height=0.95\textheight]{struct.pdf}

\secrel{Синтаксический анализатор}\secdown

\secrel{Лексер /flex/}

\termdef{Лексер}{лексер}\ --- компонент, выполняющий разделение исходного 
текста программы на элементы: \termdef{токены}{токен}.

\bigskip
Лексер умеет работать только последовательно, и не способен разпознавать такие
элементы как вложенные скобки. Задача лексера\ --- объединить определенные
смежные символы в один объект-токен, и присвоить ему метку типа (число, строка, 
оператор,..). Также лексер может запоминать в токене его положение в 
исходнике: имя файла, номер строки и столбца.

Лексер можно написать полностью самому, реализовав интерфейс:
\lstx{hpp.hpp}{tmp/lexer.hpp}{C++}

\secrel{Парсер /bison/}

\termdef{Парсер}{парсер}

\secup

\clearpage
\addcontentsline{toc}{chapter}{Индекс}
\printindex
\end{document}
